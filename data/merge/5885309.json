{"updated_at": "2012-05-23T21:35:17Z", "repo": "rails", "created_at": "2012-05-23T21:35:17Z", "owner": "rails", "url": "https://api.github.com/repos/rails/rails/issues/comments/5885309", "id": 5885309, "issue_url": "https://api.github.com/repos/rails/rails/issues/6416", "issue_id": 6416, "user": {"repos_url": "https://api.github.com/users/pmahoney/repos", "type": "User", "html_url": "https://github.com/pmahoney", "starred_url": "https://api.github.com/users/pmahoney/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmahoney/subscriptions", "following_url": "https://api.github.com/users/pmahoney/following{/other_user}", "gravatar_id": "27598e1b77ce41fb0bd8a6fc4a3715d4", "organizations_url": "https://api.github.com/users/pmahoney/orgs", "url": "https://api.github.com/users/pmahoney", "gists_url": "https://api.github.com/users/pmahoney/gists{/gist_id}", "avatar_url": "https://0.gravatar.com/avatar/27598e1b77ce41fb0bd8a6fc4a3715d4?d=https%3A%2F%2Fidenticons.github.com%2F55d630b2da03cc33c4e3f00c113d14d7.png", "id": 103822, "events_url": "https://api.github.com/users/pmahoney/events{/privacy}", "login": "pmahoney", "received_events_url": "https://api.github.com/users/pmahoney/received_events", "followers_url": "https://api.github.com/users/pmahoney/followers"}, "body": "@jrochkind it's much easier to see what's going on in this refactoring: https://github.com/pmahoney/rails/commit/ff1adc0e96bfba36ca8094288341bd667508e662  This is what I'm going to resubmit after a few more cleanups.\n\nTake a look at the Queue class.  Yes, it uses condition wait/signal.  I have found (and have tests to prove it) that if you have, say 10 threads waiting on a condition var, then do `10.times { cond.signal; sleep 1 }`, the waiting threads will wake up in the order they started waiting, consistent with the documentation of ConditionVariable).\n\nI have also found that if 5 threads start waiting, then later a second group of 5 start waiting, then calling `5.times { cond.signal }` (no sleep), the 5 threads in group1 will wake up, and none in group2.  The group1 threads will not necessarily wake up in order, but that's fine for this use case.\n\n(For what it's worth, I did implement a strictly fair queue where each waiting thread put itself into an Array and on wakeup, made sure it was first in line, or else re-signaled and began waiting again).\n\nIf that's true, then the way to prevent a new thread (one that has not been waiting) from \"stealing\" a connection from a thread that has been waiting is to check `@num_waiting`.  When a thread is waiting, it increments this number, and that holds true even when it releases the lock during the call to `#wait`.  I can easily modify Queue class to allow \"stealing\", in which case the histogram or response times looks a lot different (there are quite a few requests that take a longish time to acquire a connection).  I may blog about this and make some nicer graphs, because I found it interesting.\n\nDo those test results conflict with things you have seen?", "_id": {"$oid": "523808b2bd3543c15100cc55"}, "html_url": "https://github.com/rails/rails/pull/6416#issuecomment-5885309"}
