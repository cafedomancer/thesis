{"body": "What we want is to provide a simple API for the developers (including Rails' core ones) to derive different keys from one single master key. I'd like to see something as simple as Application.key_generator.derive_key(info), where info might contain some non-random data to identify the derived key, e.g., \"encrypted_cookie_store_key\".\n\nOne simple way you can do is to use http://www.ruby-doc.org/stdlib-2.0/libdoc/openssl/rdoc/OpenSSL/PKCS5.html#method-c-pbkdf2_hmac with SHA256 as the hash function and pass the arguments as follows:\n\n- pass: the master key\n\n- salt: info that passed by the caller\n\n- iter: 1000. We don't need anything bigger here because the master key is already random.\n\n- keylen: 256 (= hashlen). This is enough key bits for all crypto operations.\n\nThis is actually a misuse of the OpenSSL-PBKDF2 API, but we really know what we are doing here for the following reasons: \n\n1) In this settings PBKDF2-HMAC is very similar to HKDF. When keylen is equal to hashlen, HKDF would output T_1 computed as follows:\n\n    T_1 = HMAC-Hash(PRK, info | 0x01)\nand PBKDF2-HMAC would output this T_1\n\n    F (P, S, c, i) = U_1 \\xor U_2 \\xor ... \\xor U_c\n    T_1 = F (P, S, c, 1) ,\nwhere\n\n    U_1 = PRF (P, S || INT (i)) ,\n    U_2 = PRF (P, U_1) ,\n    ...\n    U_c = PRF (P, U{c-1}) .\n\nHere, S is salt (non-random info in our case), c is the iteration counter and INT (i) is a four-octet encoding of the integer i, most significant octet first. You probably notice that HKDF's T_1 is actually PBKDF2-HMAC's U_1. In other words, the 1000 iteration count actually makes PBKDF2 stronger than HKDF.\n\n2) The KDF used in SSL is super simple:\n\n     key_block =\n       MD5(master_secret + SHA(`A' + master_secret +\n                               ServerHello.random +\n                               ClientHello.random)) +\n       MD5(master_secret + SHA(`BB' + master_secret +\n                               ServerHello.random +\n                               ClientHello.random)) +\n       MD5(master_secret + SHA(`CCC' + master_secret +\n                               ServerHello.random +\n                               ClientHello.random)) + [...];\n\nbut it's Still Secure After All These Years (TM)!\n\n3) Actually in practice people also use something as simple as HMAC(master_key, \"0\") and HMAC(master_key, \"1\") to derive different keys. It's okay because HMAC is a secure PRF, so as long as the master_key is random this would generate complete random keys. \n\nSo I guess we'll be fine with the approach I propose above. Anything more complex than it is probably overkill and might confuse developers.", "url": "https://api.github.com/repos/rails/rails/issues/comments/7661220", "created_at": "2012-08-10T23:05:24Z", "html_url": "https://github.com/rails/rails/pull/6952#issuecomment-7661220", "updated_at": "2012-08-20T20:28:00Z", "repo": "rails", "issue_id": 6952, "user": {"following_url": "https://api.github.com/users/thaidn/following{/other_user}", "events_url": "https://api.github.com/users/thaidn/events{/privacy}", "organizations_url": "https://api.github.com/users/thaidn/orgs", "url": "https://api.github.com/users/thaidn", "gists_url": "https://api.github.com/users/thaidn/gists{/gist_id}", "html_url": "https://github.com/thaidn", "subscriptions_url": "https://api.github.com/users/thaidn/subscriptions", "avatar_url": "https://1.gravatar.com/avatar/b514ef10e0279a1e3a73e99633555163?d=https%3A%2F%2Fidenticons.github.com%2Faeecc5a9c646444f00978ed43e747a96.png", "repos_url": "https://api.github.com/users/thaidn/repos", "received_events_url": "https://api.github.com/users/thaidn/received_events", "gravatar_id": "b514ef10e0279a1e3a73e99633555163", "starred_url": "https://api.github.com/users/thaidn/starred{/owner}{/repo}", "login": "thaidn", "type": "User", "id": 7532, "followers_url": "https://api.github.com/users/thaidn/followers"}, "owner": "rails", "_id": {"$oid": "52380195bd3543c15100c17b"}, "id": 7661220, "issue_url": "https://api.github.com/repos/rails/rails/issues/6952"}
