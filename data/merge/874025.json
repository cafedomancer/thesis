{"updated_at": "2011-03-15T03:11:39Z", "repo": "rails", "created_at": "2011-03-15T03:11:39Z", "owner": "rails", "url": "https://api.github.com/repos/rails/rails/issues/comments/874025", "id": 874025, "issue_url": "https://api.github.com/repos/rails/rails/issues/201", "issue_id": 201, "user": {"repos_url": "https://api.github.com/users/jmileham/repos", "type": "User", "html_url": "https://github.com/jmileham", "starred_url": "https://api.github.com/users/jmileham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jmileham/subscriptions", "following_url": "https://api.github.com/users/jmileham/following{/other_user}", "gravatar_id": "079ab1cc5aa71e625bb160e62b09f09c", "organizations_url": "https://api.github.com/users/jmileham/orgs", "url": "https://api.github.com/users/jmileham", "gists_url": "https://api.github.com/users/jmileham/gists{/gist_id}", "avatar_url": "https://1.gravatar.com/avatar/079ab1cc5aa71e625bb160e62b09f09c?d=https%3A%2F%2Fidenticons.github.com%2F02c1ffbf4378893da347eb8ec50b2456.png", "id": 40619, "events_url": "https://api.github.com/users/jmileham/events{/privacy}", "login": "jmileham", "received_events_url": "https://api.github.com/users/jmileham/received_events", "followers_url": "https://api.github.com/users/jmileham/followers"}, "body": "I checked sqlite3 and MySQL and both will shortcut the count of a limited subquery, returning extremely quickly when counting 100 matching rows of a 2 million-row table.  Note that MySQL appears to cache the count of a table so as to avoid the full table scan in a trivial `select count(*) from tablename;`  But when you make it do a little bit of work (in the example below, the `LIKE` expression matches every row), which is very likely to be the case in any scoped relation, the performance win of the subquery becomes clear:\r\n\r\nThis looks fast:\r\n\r\n    mysql> select count(*) from stuff;\r\n    +----------+\r\n    | count(*) |\r\n    +----------+\r\n    |  2097152 |\r\n    +----------+\r\n    1 row in set (0.00 sec)\r\n\r\nBut when you make the database perform some manner of scan (in this case a full table scan, though in less-contrived use cases, you'd be dealing with index scans and a smaller performance hit), things get sluggish:\r\n\r\n    mysql> select count(*) from stuff where value like 'some%';\r\n    +----------+\r\n    | count(*) |\r\n    +----------+\r\n    |  2097152 |\r\n    +----------+\r\n    1 row in set (0.47 sec)\r\n\r\nThough if you don't care to know how many matching rows there are in the whole table, and just want to know how many results wil show up on a given page, then this is really fast:\r\n\r\n    mysql> select count(*) from (select 1 from stuff where value like 'some%' limit 100) t;\r\n    +----------+\r\n    | count(*) |\r\n    +----------+\r\n    |      100 |\r\n    +----------+\r\n    1 row in set (0.00 sec)\r\n\r\nSqlite3 exhibits similar behavior:\r\n\r\n    sqlite> select count(*) from stuff;\r\n    2097152\r\n    CPU Time: user 0.043846 sys 0.102457\r\n    sqlite> select count(*) from stuff where value like 'some%';\r\n    2097152\r\n    CPU Time: user 1.080249 sys 0.117463\r\n    sqlite> select count(*) from (select 1 from stuff where value like 'some%' limit 100) t;\r\n    100\r\n    CPU Time: user 0.000237 sys 0.000073\r\n\r\nFrom reading Sqlite's documentation, its subqueries are implemented by rendering the subquery to a temporary table and then driving the main query off of that result.  I suspect that characteristic may have contributed to the slowness mentioned on Andrew's database (though a time of 500ms for a scan of 500 rows is still a surprise).  Since Sqlite performs the subquery in its entirety, if the products table has a lot of columns or large TEXT columns, reading and burning that data down to a temporary table would be an expensive process with the \"SELECT *\" from his example.  Andrew's example SQL is not what the patch I submitted generates, though -- my patch performs a simple \"SELECT 1\" inside the subquery (if no column is explicitly requested) or a select on the requested column if it is.\r\n\r\nAndrew, does this address your concerns?  I'd be glad to do more research if there's an angle I'm overlooking.  If anybody has any feedback, I'd appreciate your input.\r\n\r\nThanks,\r\n-john", "_id": {"$oid": "523865dcbd3543c151012749"}, "html_url": "https://github.com/rails/rails/pull/201#issuecomment-874025"}
