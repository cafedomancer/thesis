{"body": "> iterations: should be > 10000. I use 100000 generally, but 16384 would be not bad at this moment. The key point is enough slowness and it depends on purposes.\n\nI agree, it should be at least a 5 digits number. Although, when chosen too large, this can quickly become an attack vector for denial of service attacks. It largely depends on the infrastructure of how much it can handle - maybe chose a default like @nahi proposed, but make still have it configurable somehow?\n \n>salt: should have enough entropy. Length check would be good to have. 16 bytes or more?\n\nPKCS#5 says that the salt should at least be 8 bytes, I typically also use the 16 bytes that nahi proposed. What is essential here is that these bytes must be chosen by a cryptographically secure random number generator, OpenSSL::Random or SecureRandom. Ideally a fresh, per-user salt should be used each time, to forbid any opportunity for precomputation right from the start. Normally an attacker would not know the salt, but it's better to design as if they did, which is plausible - think of bribed/rogue devs/admins etc. \nThis would however require the salt to be a part of the return value or the salt to be part of the interface, handed over by the user. The latter option has the disadvantage that users could still get things wrong with salt generation, though.\n\n> derived key length: should be specified by caller b/c it depends on purpose. SHA1 length (160bit) would be good if you need a default.\n\nYes, the security margin is tightly related to the underlying digest that was used. It can't exceed the output length of the digest - so in nahi's example of SHA-1, choosing more than 160 bit will for example not increase security. So it's probably best to choose the exact output length of the digest. Some doubt has been cast over SHA-1 recently, and the current recommendations are to use SHA-256 wherever possible. Either way, you can then conveniently choose the dk_len parameter as OpenSSL::Digest#digest_length.\n\nOne final note about timing attacks when comparing password hashes. It is argued from time to time on the web that one would have to use some \"equal time\" comparison methods to compare password hashes in order to not leak any information subject to timing attacks. This is a very delicate issue. I asked a cryptographer who I can absolutely trust on these matters and his advice was as follows: If the underlying hash function were ideal, this attack would be even harder than finding collisions or preimages. So in theory there's no need to worry. *But*, since current hash functions cannot be proven to be ideal, it doesn't hurt to do equal time comparison, better safe than sorry.\n\nIf you'd like to follow his advice, the best method that I see currently for doing equal time comparisons is to do something like this:\n\n    d = #some digest\n    h1 = #first password hash\n    h2 = #second password hash\n    if d.digest(h1) == d.digest(h2)\n      #success\n    else\n      #fail\n    end\n\nExecution time of computing a digest is independent of its input. This method was also proposed in Dan Boneh's cryptography course on Coursera, so I believe we can trust it. The issue with other popular methods (keeping a \"running sum\" of XORs of the individual bits) besides being sufficiently complicated is often that optimizing compilers might one day \"see what we did there\" and would \"optimize\" our efforts away :)", "url": "https://api.github.com/repos/rails/rails/issues/comments/6755113", "created_at": "2012-07-04T08:25:43Z", "html_url": "https://github.com/rails/rails/pull/6952#issuecomment-6755113", "updated_at": "2012-07-04T11:23:46Z", "repo": "rails", "issue_id": 6952, "user": {"following_url": "https://api.github.com/users/emboss/following{/other_user}", "events_url": "https://api.github.com/users/emboss/events{/privacy}", "organizations_url": "https://api.github.com/users/emboss/orgs", "url": "https://api.github.com/users/emboss", "gists_url": "https://api.github.com/users/emboss/gists{/gist_id}", "html_url": "https://github.com/emboss", "subscriptions_url": "https://api.github.com/users/emboss/subscriptions", "avatar_url": "https://0.gravatar.com/avatar/ada56d152c1abe0eba65a5ff62ed5387?d=https%3A%2F%2Fidenticons.github.com%2F3e0ccfd5b27c3147b2a9e7d02f862c91.png", "repos_url": "https://api.github.com/users/emboss/repos", "received_events_url": "https://api.github.com/users/emboss/received_events", "gravatar_id": "ada56d152c1abe0eba65a5ff62ed5387", "starred_url": "https://api.github.com/users/emboss/starred{/owner}{/repo}", "login": "emboss", "type": "User", "id": 486012, "followers_url": "https://api.github.com/users/emboss/followers"}, "owner": "rails", "_id": {"$oid": "52380195bd3543c15100c16e"}, "id": 6755113, "issue_url": "https://api.github.com/repos/rails/rails/issues/6952"}
