{"body": "Hello, guys. This is greate feature, I like \"algorithm: :concurrently\". But right now this feature doesn't work for PostgreSQL (I didn't check MySQL). First of all we should look at PostgreSQL documentation:\r\n\r\nhttp://www.postgresql.org/docs/9.2/static/sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY\r\n\r\n> Regular index builds permit other regular index builds on the same table to occur in parallel, but only one concurrent index build can occur on a table at a time. In both cases, no other types of schema modification on the table are allowed meanwhile. **Another difference is that a regular CREATE INDEX command can be performed within a transaction block, but CREATE INDEX CONCURRENTLY cannot**.\r\n\r\nAnd of course each migration for PostgreSQL works in transaction block (it's perfect, because on fail it will rollback all changes). \r\n\r\nI worked under this feature also and when I saw this pull request, I didn't found in changes, how this solved.\r\n\r\nSo right now for such migration:\r\n\r\n```ruby\r\nclass CreateUsers < ActiveRecord::Migration\r\n  def change\r\n    create_table :users do |t|\r\n      t.string :email\r\n      t.timestamps\r\n    end\r\n    add_index :users, :email, algorithm: :concurrently\r\n  end\r\nend\r\n``` \r\n\r\nwe have such problem:\r\n\r\n```bash\r\n$ rake db:migrate\r\n \r\n==  CreateUsers: migrating ====================================================\r\n-- create_table(:users)\r\n   -> 0.0274s\r\n-- add_index(:users, :email, {:algorithm=>:concurrently})\r\nrake aborted!\r\nAn error has occurred, this and all later migrations canceled:\r\n\r\nPG::Error: ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block\r\n: CREATE  INDEX CONCURRENTLY \"index_users_on_email\" ON \"users\"  (\"email\")/Users/leo/.rvm/gems/ruby-2.0.0-p0/bundler/gems/rails-3b0b573ac3ec/activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb:128:in `exec'\r\n/Users/leo/.rvm/gems/ruby-2.0.0-p0/bundler/gems/rails-3b0b573ac3ec/activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb:128:in `block in execute'\r\n/Users/leo/.rvm/gems/ruby-2.0.0-p0/bundler/gems/rails-3b0b573ac3ec/activerecord/lib/active_record/connection_adapters/abstract_adapter.rb:425:in `block in log'\r\n/Users/leo/.rvm/gems/ruby-2.0.0-p0/bundler/gems/rails-3b0b573ac3ec/activesupport/lib/active_support/notifications/instrumenter.rb:20:in `instrument'\r\n/Users/leo/.rvm/gems/ruby-2.0.0-p0/bundler/gems/rails-3b0b573ac3ec/activerecord/lib/active_record/connection_adapters/abstract_adapter.rb:420:in `log'\r\n/Users/leo/.rvm/gems/ruby-2.0.0-p0/bundler/gems/rails-3b0b573ac3ec/activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb:127:in `execute'\r\n/Users/leo/.rvm/gems/ruby-2.0.0-p0/bundler/gems/rails-3b0b573ac3ec/activerecord/lib/active_record/connection_adapters/postgresql/schema_statements.rb:416:in `add_index'\r\n/Users/leo/.rvm/gems/ruby-2.0.0-p0/bundler/gems/rails-...\r\n...\r\nTasks: TOP => db:migrate\r\n(See full trace by running task with --trace)\r\n\r\n```\r\n\r\nTo create such indexes, I think in code should exists some queue, which will collect all such indexes in migration and execute this indexes after success execution of transaction block.\r\n\r\nP.S. rails tested version:\r\n\r\n```ruby\r\nGIT\r\n  remote: git://github.com/rails/rails.git\r\n  revision: 3b0b573ac3ecbec5b1fa021abbe86b267bbefb8c\r\n  specs:\r\n    actionmailer (4.0.0.beta1)\r\n      actionpack (= 4.0.0.beta1)\r\n      mail (~> 2.5.3)\r\n    actionpack (4.0.0.beta1)\r\n      activesupport (= 4.0.0.beta1)\r\n      builder (~> 3.1.0)\r\n      erubis (~> 2.7.0)\r\n      rack (~> 1.5.2)\r\n      rack-test (~> 0.6.2)\r\n    activemodel (4.0.0.beta1)\r\n      activesupport (= 4.0.0.beta1)\r\n      builder (~> 3.1.0)\r\n    activerecord (4.0.0.beta1)\r\n      activemodel (= 4.0.0.beta1)\r\n      activerecord-deprecated_finders (~> 0.0.3)\r\n      activesupport (= 4.0.0.beta1)\r\n      arel (~> 4.0.0.beta2)\r\n    activesupport (4.0.0.beta1)\r\n      i18n (~> 0.6, >= 0.6.4)\r\n      minitest (~> 4.2)\r\n      multi_json (~> 1.3)\r\n      thread_safe (~> 0.1)\r\n      tzinfo (~> 0.3.37)\r\n    rails (4.0.0.beta1)\r\n      actionmailer (= 4.0.0.beta1)\r\n      actionpack (= 4.0.0.beta1)\r\n      activerecord (= 4.0.0.beta1)\r\n      activesupport (= 4.0.0.beta1)\r\n      bundler (>= 1.3.0, < 2.0)\r\n      railties (= 4.0.0.beta1)\r\n      sprockets-rails (~> 2.0.0.rc3)\r\n    railties (4.0.0.beta1)\r\n      actionpack (= 4.0.0.beta1)\r\n      activesupport (= 4.0.0.beta1)\r\n      rake (>= 0.8.7)\r\n      thor (>= 0.18.1, < 2.0)\r\n```\r\n\r\nThanks for all.", "url": "https://api.github.com/repos/rails/rails/issues/comments/15680862", "created_at": "2013-03-30T20:01:31Z", "html_url": "https://github.com/rails/rails/pull/9923#issuecomment-15680862", "updated_at": "2013-03-30T20:01:31Z", "repo": "rails", "issue_id": 9923, "user": {"following_url": "https://api.github.com/users/le0pard/following{/other_user}", "events_url": "https://api.github.com/users/le0pard/events{/privacy}", "organizations_url": "https://api.github.com/users/le0pard/orgs", "url": "https://api.github.com/users/le0pard", "gists_url": "https://api.github.com/users/le0pard/gists{/gist_id}", "html_url": "https://github.com/le0pard", "subscriptions_url": "https://api.github.com/users/le0pard/subscriptions", "avatar_url": "https://0.gravatar.com/avatar/2b18d4346ca1ec18cb310cd86a51a4e2?d=https%3A%2F%2Fidenticons.github.com%2Fd9fd0920d5e926e0620d8222a3454af4.png", "repos_url": "https://api.github.com/users/le0pard/repos", "received_events_url": "https://api.github.com/users/le0pard/received_events", "gravatar_id": "2b18d4346ca1ec18cb310cd86a51a4e2", "starred_url": "https://api.github.com/users/le0pard/starred{/owner}{/repo}", "login": "le0pard", "type": "User", "id": 98444, "followers_url": "https://api.github.com/users/le0pard/followers"}, "owner": "rails", "_id": {"$oid": "523d06b9bd354364b9003e8f"}, "id": 15680862, "issue_url": "https://api.github.com/repos/rails/rails/issues/9923"}
