{"issue_url": "https://api.github.com/repos/rails/rails/issues/6952", "repo": "rails", "body": "@rkh In this case it doesn't add to the security, I would agree. But using a salt would make it possible to derive \"sub keys\" from the master key in a reproducible way. \n\n> Sorry, real life intervened.\n\nNo problem, it keeps doing that sometimes ;)\n\nThe salt itself can be treated as if it were public once established, but to prevent the ability to precompute values it should be selected randomly at some point. Instead of hardcoding them once and for all, would it be possible to set the individual values for cookie signing etc. at application generation time, together with the master key?\n\nThis part from PKCS#5 seems also good advice:\n\n> 2) Otherwise, the salt should contain data that explicitly\n         distinguishes between different operations and different key\n         lengths, in addition to a random part that is at least eight\n         octets long, and this data should be checked or regenerated by\n         the party receiving the salt. For instance, the salt could have\n         an additional non-random octet that specifies the purpose of\n         the derived key. Alternatively, it could be the encoding of a\n         structure that specifies detailed information about the derived\n         key, such as the encryption or authentication technique and a\n         sequence number among the different keys derived from the\n         password.  The particular format of the additional data is left\n         to the application.\n\nTaking this into account, how about prefixing the salt with the purpose and then adding a random part? Something like\n\n    \"org.rubyonrails.cookies.signature7da55e95cab4feae54f0a8af22a4e0a1280b63b5d5055948066\"\n\nThe raw, (non-hex) salt should still be at least 8 bytes long, to prevent generating the same key twice for different applications:\n\n>2) It is unlikely that the same key will be selected twice.\n         Again, if the salt is 64 bits long, the chance of \"collision\"\n         between keys does not become significant until about 2^32 keys\n         have been produced, according to the Birthday Paradox. This\n         addresses some of the concerns about interactions between\n         multiple uses of the same key, which may apply for some\n         encryption and authentication techniques.\n\nSince the original master key is already secure random, I would assume it's fine to stay modest with the iterations...\n\n@nahi Would you agree?", "_id": {"$oid": "52380195bd3543c15100c17a"}, "issue_id": 6952, "url": "https://api.github.com/repos/rails/rails/issues/comments/7021446", "html_url": "https://github.com/rails/rails/pull/6952#issuecomment-7021446", "updated_at": "2012-07-16T22:27:55Z", "user": {"subscriptions_url": "https://api.github.com/users/emboss/subscriptions", "events_url": "https://api.github.com/users/emboss/events{/privacy}", "repos_url": "https://api.github.com/users/emboss/repos", "gists_url": "https://api.github.com/users/emboss/gists{/gist_id}", "url": "https://api.github.com/users/emboss", "login": "emboss", "gravatar_id": "ada56d152c1abe0eba65a5ff62ed5387", "html_url": "https://github.com/emboss", "following_url": "https://api.github.com/users/emboss/following{/other_user}", "received_events_url": "https://api.github.com/users/emboss/received_events", "organizations_url": "https://api.github.com/users/emboss/orgs", "avatar_url": "https://0.gravatar.com/avatar/ada56d152c1abe0eba65a5ff62ed5387?d=https%3A%2F%2Fidenticons.github.com%2F3e0ccfd5b27c3147b2a9e7d02f862c91.png", "starred_url": "https://api.github.com/users/emboss/starred{/owner}{/repo}", "id": 486012, "followers_url": "https://api.github.com/users/emboss/followers", "type": "User"}, "created_at": "2012-07-16T22:27:55Z", "id": 7021446, "owner": "rails"}
