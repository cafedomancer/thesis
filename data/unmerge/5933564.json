{"updated_at": "2012-05-25T15:45:50Z", "repo": "rails", "created_at": "2012-05-25T15:42:13Z", "owner": "rails", "url": "https://api.github.com/repos/rails/rails/issues/comments/5933564", "id": 5933564, "issue_url": "https://api.github.com/repos/rails/rails/issues/6488", "issue_id": 6488, "user": {"repos_url": "https://api.github.com/users/jrochkind/repos", "type": "User", "html_url": "https://github.com/jrochkind", "starred_url": "https://api.github.com/users/jrochkind/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jrochkind/subscriptions", "following_url": "https://api.github.com/users/jrochkind/following{/other_user}", "gravatar_id": "6a13e655e637138f8d571cec3f9cea76", "organizations_url": "https://api.github.com/users/jrochkind/orgs", "url": "https://api.github.com/users/jrochkind", "gists_url": "https://api.github.com/users/jrochkind/gists{/gist_id}", "avatar_url": "https://0.gravatar.com/avatar/6a13e655e637138f8d571cec3f9cea76?d=https%3A%2F%2Fidenticons.github.com%2Fd54ea80e1dddb765bab019d4dfe36c23.png", "id": 149304, "events_url": "https://api.github.com/users/jrochkind/events{/privacy}", "login": "jrochkind", "received_events_url": "https://api.github.com/users/jrochkind/received_events", "followers_url": "https://api.github.com/users/jrochkind/followers"}, "body": "Awesome. This definitely deals with some troubles i've been having. \n\n1. \n     > We don't need strict fairness: if two connections become\n     > available at the same time, it's fine of two threads that were\n     >  waiting acquire the connections out of order.\n\n     What keeps you from being strictly fair? Strict fairness (or close to it barring edge cases) would work out even better for me, although this will still be a huge improvement.  Per our previous conversation where I think you said that if multiple threads were waiting, #signal would always wake up the one that was waiting the longest (verified in both jruby and mri?) -- what prevents strict fairness from being implemented?    (The kind of fairness enforced here is still much better, and possibly good enough even for my use case, just curious if it can be improved yet further). \n     * I notice even though your comments say you don't care about strict fairness -- your test actually _does_ verify strict order with the order test, no?  Are the comments outdated, strict fairness really is being guaranteed by the test?\n\n2.  What's the [`@cond.broadcast`](https://github.com/pmahoney/rails/commit/8d049393f713f48611ab3ce033bb4e3ad94a464c#L0R299) needed for? What was failing without this that required this?  Related to first point above?  I ask because previous implementations (3-2-stable as well as master) did not use a `broadcast`, but it didn't seem to cause any problems -- the threads that ended up waiting indefinitely in master previously were not caused by a lack of broadcast, they were caused by the situation you fixed with `@num_wait` and your semi-fair guarantee, as well as code that didn't keep track of total time waiting so threads would keep loop-waiting indefinitely when other threads 'stole' connections. ", "_id": {"$oid": "52380786bd3543c15100cada"}, "html_url": "https://github.com/rails/rails/pull/6488#issuecomment-5933564"}
