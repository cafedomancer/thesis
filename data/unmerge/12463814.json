{"body": "@yakko The idea is to be able to access the SID for the current session,\r\nand instead of receiving `nil` if one wasn't persisted or hasn't been\r\ncreated yet, then one should be created so it's SID can be returned.\r\nThis same auto-creation happens when you attempt to write to the session.\r\nIn other words, a work-around for this would be something like:\r\n\r\n```ruby\r\nsession.delete(:foo) unless session.exists?\r\nsid = session.options[:id]\r\n```\r\n\r\nSo, the problem you're describing would be an issue regardless.\r\nIf you have the `csrf_meta_tags` in your layout, you're going to get\r\na cookie, even if you skip the filter.\r\n\r\n@rafaelfranca I've updated the commits to reflect my latest understanding\r\nof this problem (which could certainly be improved). More could certainly\r\nbe done, especially in the tests, but I'll wait to see what others think\r\nabout this before I do any more with this.\r\n\r\nAs for removing `test_setting_session_id_to_nil_is_respected`,\r\nthis test simply sets session.options[:id] to nil, then reads it back\r\nwithout making a another request. The session[:session_id] key will\r\nstill be written in the cookie using the prior SID. There is nothing taking\r\nplace when setting `session.options[:id] = nil` that would change this\r\nvalue in the CookieStore's unpacked_cookie_data (like destroy_session does).\r\nThis would occur before or after the other commits here are applied.\r\n\r\nIf setting the SID to nil should destroy the session, but not create a\r\nnew SID, perhaps Options[]= could call @by.send(:destroy_session) with\r\nthe :drop option - but the other stores wouldn't support this.\r\nI'm not understanding _why_ you would want to do this, rather than calling\r\nreset_session or session.destroy. So I'm a bit confused as to how this\r\nshould be handled.\r\n", "url": "https://api.github.com/repos/rails/rails/issues/comments/12463814", "created_at": "2013-01-20T00:26:46Z", "html_url": "https://github.com/rails/rails/pull/8961#issuecomment-12463814", "updated_at": "2013-01-20T00:26:46Z", "repo": "rails", "issue_id": 8961, "user": {"following_url": "https://api.github.com/users/burns/following{/other_user}", "events_url": "https://api.github.com/users/burns/events{/privacy}", "organizations_url": "https://api.github.com/users/burns/orgs", "url": "https://api.github.com/users/burns", "gists_url": "https://api.github.com/users/burns/gists{/gist_id}", "html_url": "https://github.com/burns", "subscriptions_url": "https://api.github.com/users/burns/subscriptions", "avatar_url": "https://1.gravatar.com/avatar/dc03efb58652b74e28722beb5d5c1826?d=https%3A%2F%2Fidenticons.github.com%2F6229c8950a89834489d855c14d32576f.png", "repos_url": "https://api.github.com/users/burns/repos", "received_events_url": "https://api.github.com/users/burns/received_events", "gravatar_id": "dc03efb58652b74e28722beb5d5c1826", "starred_url": "https://api.github.com/users/burns/starred{/owner}{/repo}", "login": "burns", "type": "User", "id": 198303, "followers_url": "https://api.github.com/users/burns/followers"}, "owner": "rails", "_id": {"$oid": "523d60d7bd354364b9006514"}, "id": 12463814, "issue_url": "https://api.github.com/repos/rails/rails/issues/8961"}
