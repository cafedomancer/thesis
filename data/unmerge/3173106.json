{"issue_url": "https://api.github.com/repos/rails/rails/issues/505", "repo": "rails", "body": "> Supposedly, RFC2616 has been enforcing 'full PUT' for over 12 years and we're still yet to see any significant mechanisms that leverage this systemic agreement on the fullness of PUT requests.. that should tell us something (i.e. it's a useless semantic). Add in the fact we have implementations, like Rails, which blatantly disregard it and don't appear to suffer any real negative consequences.. I think it's a serious stretch to compare this to IE6.\r\n\r\n@mikekelly: I don't think it's a matter of \"real negative consequences\"; rather, there are very, very positive benefits to implementing PUT correctly that are simply _impossible_ to achieve when the server is not following proper PUT semantics.  I've got a recent internal HTTP service that I built with sinatra and it was very easy to get proper PUT semantics.  The app uses PUT both for create and update, and only allows full representations to be used.  Here are some of the benefits we've received:\r\n\r\n* Since PUTs are idempotent, they can be re-tried as many times as you want. We rely on this a lot. The service is consumed by our main rails app. The rails app performs the PUT to the sinatra service using a resque job, and it's very easy to retry the job when we have a transient failure. It _just works_.\r\n* The fact that we use PUT for both create and update makes the client code exceptionally simple. We don't need to deal with two separate types of requests to ensure the sinatra service has the resource in the proper state. We just use a PUT, and it doesn't matter if the resource exists or not, or whether or not the resource is already in the desired state; the end result is the same.  We also leverage this in a cron job that runs every few days for the express purpose of reconciling any discrepancies between the user configuration data in the rails app and the data in the sinatra app.  It goes over every user, does a GET to the sinatra app to get the data, compares the data to what it has locally, and does a PUT if there is a discrepancy or if the sinatra app responds with 404 not found.  Again, the idempotent, create-or-update nature of the PUT makes this extremely easy. \r\n* The fact that we use PUT for create (and thus allow the client to pick the identifier) makes the service very transparent and easy to troubleshoot.  When one of the users of the rails app has some missing data I don't have to go look up the id of the corresponding record in the sinatra service; I can easily construct URLs directly in my browser using the user ID I already know.\r\n\r\nNone of these benefits would be possible if we had implemented the normal rails PUT semantics in our sinatra service.\r\n\r\nSo here's my two cents (not that anyone asked for it....).  I'd love to see rails provide support to easily implement proper PUT semantics.  As part of this, some other HTTP verb should be used for partial updates. PATCH looks interesting, but POST can be used today and is the correct verb to use.  In addition, it would be great if ActiveRecord/ActiveModel provided an `replace_attributes` method that only supported FULL updates and no partial updates.  It would effectively be like `update_attributes` except that it would set any unmentioned attributes to `nil`.  Most of the time, this would cause the partial update to fail with validation errors, which is the correct behavior you would usually want.", "_id": {"$oid": "52385f14bd3543c151012130"}, "issue_id": 505, "url": "https://api.github.com/repos/rails/rails/issues/comments/3173106", "html_url": "https://github.com/rails/rails/pull/505#issuecomment-3173106", "updated_at": "2011-12-16T04:17:07Z", "user": {"subscriptions_url": "https://api.github.com/users/myronmarston/subscriptions", "events_url": "https://api.github.com/users/myronmarston/events{/privacy}", "repos_url": "https://api.github.com/users/myronmarston/repos", "gists_url": "https://api.github.com/users/myronmarston/gists{/gist_id}", "url": "https://api.github.com/users/myronmarston", "login": "myronmarston", "gravatar_id": "42d4590355a1404230fbc9aff4dd377b", "html_url": "https://github.com/myronmarston", "following_url": "https://api.github.com/users/myronmarston/following{/other_user}", "received_events_url": "https://api.github.com/users/myronmarston/received_events", "organizations_url": "https://api.github.com/users/myronmarston/orgs", "avatar_url": "https://2.gravatar.com/avatar/42d4590355a1404230fbc9aff4dd377b?d=https%3A%2F%2Fidenticons.github.com%2F6916222172eb021e5d5f0043453078b9.png", "starred_url": "https://api.github.com/users/myronmarston/starred{/owner}{/repo}", "id": 49391, "followers_url": "https://api.github.com/users/myronmarston/followers", "type": "User"}, "created_at": "2011-12-16T04:17:07Z", "id": 3173106, "owner": "rails"}
