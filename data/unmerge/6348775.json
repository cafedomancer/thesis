{"updated_at": "2012-06-15T03:27:46Z", "repo": "rails", "created_at": "2012-06-15T03:26:52Z", "owner": "rails", "url": "https://api.github.com/repos/rails/rails/issues/comments/6348775", "id": 6348775, "issue_url": "https://api.github.com/repos/rails/rails/issues/6685", "issue_id": 6685, "user": {"repos_url": "https://api.github.com/users/tarcieri/repos", "type": "User", "html_url": "https://github.com/tarcieri", "starred_url": "https://api.github.com/users/tarcieri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tarcieri/subscriptions", "following_url": "https://api.github.com/users/tarcieri/following{/other_user}", "gravatar_id": "4131d2f57a0db2a2b4d9a62bd389fd44", "organizations_url": "https://api.github.com/users/tarcieri/orgs", "url": "https://api.github.com/users/tarcieri", "gists_url": "https://api.github.com/users/tarcieri/gists{/gist_id}", "avatar_url": "https://1.gravatar.com/avatar/4131d2f57a0db2a2b4d9a62bd389fd44?d=https%3A%2F%2Fidenticons.github.com%2Fbeb22fb694d513edcf5533cf006dfeae.png", "id": 797, "events_url": "https://api.github.com/users/tarcieri/events{/privacy}", "login": "tarcieri", "received_events_url": "https://api.github.com/users/tarcieri/received_events", "followers_url": "https://api.github.com/users/tarcieri/followers"}, "body": "@headius my experience with single-threaded MRIs has been people are afraid to have long-running requests in Rails in general, because long-running requests block an instance that could otherwise be servicing traffic.\n\nThere have been many times throughout the history of my usage of Rails where I would like to do things like make requests to APIs that might take a long time to return a response (or hit many APIs at once), or dynamically generate a large response that may be quick to generate but takes a long time to stream to a client (X-Sendfile, anyone?). These are examples of primarily I/O bound activities that would prevent a Rails application from continuing to process requests.\n\nAs soon as you run into any of these sorts of use cases threads begin to look extremely attractive, because without them you have an entire instance sitting around doing nothing while it's waiting for I/O. You have 50MB+ (on a good day) dedicated to servicing a single concurrent request, and all that memory is wasted while that process blocks waiting on I/O. These same use cases are what have driven people to try to run Rails on top of EventMachine with em-synchrony.\n\nWhenever people run into these sorts of use cases now, I think the typical solution is to stick the requested action into a queue and let the client poll for the result. This adds a lot of incidental complexity to both the implementation and the API. That's not to say that background job queues aren't useful and I'm really excited to see the work going into Rails 4 around a standard queue API, but for a lot of use cases, threads would allow people to just write synchronous APIs for these use cases and make everyone's lives easier.\n\nThe problem is that thread safe mode is off by default, so people are afraid to turn it on, and because of that fear they engineer around the limitations of a single-threaded model.", "_id": {"$oid": "52380552bd3543c15100c711"}, "html_url": "https://github.com/rails/rails/pull/6685#issuecomment-6348775"}
