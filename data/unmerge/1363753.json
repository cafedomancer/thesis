{"updated_at": "2011-06-14T04:21:14Z", "repo": "rails", "created_at": "2011-06-14T04:21:14Z", "owner": "rails", "url": "https://api.github.com/repos/rails/rails/issues/comments/1363753", "id": 1363753, "issue_url": "https://api.github.com/repos/rails/rails/issues/1686", "issue_id": 1686, "user": {"repos_url": "https://api.github.com/users/pixeltrix/repos", "type": "User", "html_url": "https://github.com/pixeltrix", "starred_url": "https://api.github.com/users/pixeltrix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pixeltrix/subscriptions", "following_url": "https://api.github.com/users/pixeltrix/following{/other_user}", "gravatar_id": "b14001f2b40640dd6cb63f0e8f1f4869", "organizations_url": "https://api.github.com/users/pixeltrix/orgs", "url": "https://api.github.com/users/pixeltrix", "gists_url": "https://api.github.com/users/pixeltrix/gists{/gist_id}", "avatar_url": "https://2.gravatar.com/avatar/b14001f2b40640dd6cb63f0e8f1f4869?d=https%3A%2F%2Fidenticons.github.com%2F7cb36e23529e4de4c41460940cc85e6e.png", "id": 6321, "events_url": "https://api.github.com/users/pixeltrix/events{/privacy}", "login": "pixeltrix", "received_events_url": "https://api.github.com/users/pixeltrix/received_events", "followers_url": "https://api.github.com/users/pixeltrix/followers"}, "body": "Firstly if we were going to merge this we'd need support for polymorphic belongs_to and has_one as well. However it could be seen as a security flaw because an end user could manipulate the form sent back to create any object they wanted, e.g:\r\n\r\n``` ruby\r\n@tree.birds.create(:type => 'Administrator', ...)\r\n```\r\n\r\nYou'd need to validate the class is a subclass of the original at a minimum but you might still have problems where the subclass has elevated privileges. What I do is to override `new` in a class where I want to do something like this:\r\n\r\n``` ruby\r\nclass Page < ActiveRecord::Base\r\n  class << self\r\n    def new(attributes = {}, options = {}, &block)\r\n      page_type = attributes.delete(:page_type)\r\n      return super if page_type.blank?\r\n\r\n      klass_name = \"#{page_type.to_s.camelize}Page\"\r\n      if Object.const_defined?(klass_name)\r\n        klass = Object.const_get(klass_name)\r\n      else\r\n        begin\r\n          klass = Object.const_missing(klass_name)\r\n        rescue NameError => e\r\n          if e.instance_of?(NameError)\r\n            raise ArgumentError, \"Unknown page type: #{page_type}\"\r\n          else\r\n            raise e\r\n          end\r\n        end\r\n      end\r\n\r\n      klass.new(attributes, options, &block)\r\n    end\r\n  end\r\nend\r\n\r\n# Examples\r\npage = Page.create!(:page_type => :product)\r\npage = @site.pages.create!(:page_type => :product)\r\npage = @product.create_page!(:page_type => :product)\r\n```\r\n\r\nThis way is more flexible and doesn't leave a website open to hacking the attributes hash.", "_id": {"$oid": "5238515cbd3543c15101177b"}, "html_url": "https://github.com/rails/rails/pull/1686#issuecomment-1363753"}
