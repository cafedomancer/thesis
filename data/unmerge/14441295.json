{"updated_at": "2013-03-05T14:05:34Z", "repo": "rails", "created_at": "2013-03-05T14:05:34Z", "owner": "rails", "url": "https://api.github.com/repos/rails/rails/issues/comments/14441295", "id": 14441295, "issue_url": "https://api.github.com/repos/rails/rails/issues/9551", "issue_id": 9551, "user": {"repos_url": "https://api.github.com/users/ernie/repos", "type": "User", "html_url": "https://github.com/ernie", "starred_url": "https://api.github.com/users/ernie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ernie/subscriptions", "following_url": "https://api.github.com/users/ernie/following{/other_user}", "gravatar_id": "2274a7476f6d2ac7aedcdec0651d0542", "organizations_url": "https://api.github.com/users/ernie/orgs", "url": "https://api.github.com/users/ernie", "gists_url": "https://api.github.com/users/ernie/gists{/gist_id}", "avatar_url": "https://2.gravatar.com/avatar/2274a7476f6d2ac7aedcdec0651d0542?d=https%3A%2F%2Fidenticons.github.com%2F6a600c968f4e6a843dcaf600c1694e42.png", "id": 14947, "events_url": "https://api.github.com/users/ernie/events{/privacy}", "login": "ernie", "received_events_url": "https://api.github.com/users/ernie/received_events", "followers_url": "https://api.github.com/users/ernie/followers"}, "body": "@jeremy thanks for taking a look. Are you sure there isn't room for a bit more discussion on this one before closing it?\r\n\r\nLeaving aside the discussion of whether `where.<predicate>` is a good idea for the API for a moment, I'm concerned that we're locking ourselves in to a specific implementation before it's needed. It would be easy to at some point alter a `where_not` implementation to use a WhereChain and transition people to `where.not` should that API design prove useful for other predicates in the long run. As it sits, we're adding complexity to the `where` method, adding another class, and sending to private methods on the parent in order to make it all work, for something that people might extend in the future.\r\n\r\nBack in the AR 3.x days, we supported only equality (and, for certain value types, IN/BETWEEN). There was a good deal of discussion around what a more full-featured API for creating other ARel predicates might look like, among them @lifo's SuperCondition implementation, which formed the basis for MetaWhere at the time. The suggestion at the time was that we would take a look at what plugins were developed and seemed to be most useful and at some point in the future consider selecting one for integration into core.\r\n\r\nHere we are, 3 years later, and as best I can tell that isn't what is happening here. I haven't seen the implementation we've gone ahead with extensively tested in plugin form, but we're integrating it all the same. As such, I'm disappointed to see additional complexity in an implementation with the promise of some potential future ecosystem developing around it driving additions to core, when that has historically not been the case for the AR query API.\r\n\r\nGiven that I have skin in the game, here, I should clarify that I'm not necessarily saying that we *need* to implement Squeel's version of predicate building. I know it may not be for everyone. But I am saying that I built both MetaWhere and Squeel as proofs-of-concept based on the expectation that they would be included in the running for an eventual enhanced query builder API, and they have received far more real-world usage than the API we've landed on.\r\n\r\nMy last attempt at driving some discussion around this was at https://groups.google.com/d/msg/rubyonrails-core/evUmld2Mal4/PGFLjX9ZeNkJ and met with a lackluster response.\r\n\r\nTo summarize, these are the drawbacks I see with this approach at first glance:\r\n\r\n* Alteration of types (both duck- and actual) throughout a method chain, making order of messages being sent important where it previously was not\r\n* Existing methods for relation composition map closely to the query domain, mapping to specific clauses of the query for this most part. `where.not` (or, for that matter, `where_not`) breaks this trend\r\n* Should the pattern be extended to other predicates, we find ourselves chunking our where clauses by type of predicate instead of by related concept or attribute, or reverting back to string queries. The likelihood that scopes will hide this fact from typical application use cases does not prevent it from having a certain smell.\r\n* The implementation as it sits today is awkward (injecting the previous scope, sending to its private `build_where` method, and branching based on a number of possible return types then mutating and returning the injected scope), and we should stop to consider whether the feature envy is telling us something.", "_id": {"$oid": "5237e866bd3543c1510096ed"}, "html_url": "https://github.com/rails/rails/pull/9551#issuecomment-14441295"}
